<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="klp.xml" version="5.0" xml:id="cha-klp" xml:lang="zh-cn">
 <title>使用 KLP 的在线内核增补</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>是</dm:translation>
  </dm:docmanager>
  <abstract>
   <para>
    本文档介绍内核在线增补 (KLP) 技术的基本原理，并提供 SLE Live Patching 服务的使用准则。
   </para>
  </abstract>
 </info>
 <para>
  KLP 是一项在线增补技术，使用它可在运行时增补 Linux 内核，而无需停止内核。如此可以最大程度地确保系统运行时间，从而提高系统可用性，这对于任务关键型系统而言非常重要。该技术还允许动态增补内核，支持用户安装关键的安全性更新，而不必将它们推迟到安排的停机时间。
 </para>
 <para>
   启用 KLP 无需执行特殊步骤，只需启用 Live Patching 服务，然后应用可用的增补程序即可。该服务是常规软件管理系统的一部分，使用常用包管理工具安装（或去除）增补程序。无需安装或手动选择特殊内核。
</para>
 <para>
  KLP 增补程序是一个内核模块，用于替换内核中的全部函数。内核在线增补主要提供内核中基础结构，可在运行时将增补的代码与基本内核代码集成。
 </para>
 <para>
  本文档中提供的信息与 AMD64/Intel 64 和 POWER 体系结构相关。Xen 超级管理程序支持 KLP。
 </para>
 <sect1 xml:id="sec-klp-advantages">
  <title>内核在线增补的优势</title>

  <para>
   当发现应该尽快修复的严重漏洞或系统稳定性问题时，使用 KLP 的内核在线增补能够快速做出紧急响应。该技术不适合用于非时间关键型的已安排更新。
  </para>

  <para>
   内核在线增补的典型用例包括：配有巨量 RAM 且引导时间通常长达 15 分钟或以上的内存数据库之类的系统、需要持续数周或数月不重启动的大规模仿真，或是向众多客户持续提供服务的基础结构构建块组。
  </para>

  <para>
   内核在线增补的主要优势是它永不要求停止内核，哪怕是短暂停止。
  </para>

  <para>
   KLP 增补程序是 RPM 包中的一个 <filename>.ko</filename> 内核模块。可以在安装或更新 包时，使用 <command>insmod</command> 命令将它插入内核。内核在线增补将替换内核中的全部函数，即使这些函数正在执行。如果需要，可以使用更新的 KLP 模块替换现有增补程序。
  </para>

  <para>
   此外，内核在线增补非常精简 - 因为利用了其他标准 Linux 技术，它只包含少量的代码。
  </para>
 </sect1>
 <sect1 xml:id="sec-klp-low-level">
  <title>内核在线增补的低级函数</title>

  <para>
   内核在线增补使用 ftrace 基础结构执行增补。下面介绍了在 AMD64/Intel 64 体系结构上的实施过程。
  </para>

  <para>
   为了增补某个内核函数，内核在线增补要求该函数的开头有一定的空间，以便插入指向新函数的跳跃点。此空间是在开启函数分析的情况下，在内核编译期间由 GCC 分配的。具体而言，将在内核函数的开头注入一个 5 字节调用指令。引导此类经过检测的内核时，分析调用将替换为 5 字节 NOP（无操作）指令。
  </para>

  <para>
   增补开始之后，第一个字节将替换为 INT3（断点）指令。这可以确保 5 字节指令替换的原子性。其他四个字节将替换为新函数的地址。最后，第一个字节将替换为 JMP（长跳跃）操作代码。
  </para>

  <para>
   在整个过程中，将使用处理器间不可屏蔽中断 (IPI NMI) 来刷新系统中其他 CPU 的推理解码队列。这样，无需停止内核（哪怕是非常短暂的停止），就能切换到新的函数。IPI NMI 产生的中断可用毫秒为单位测量，并且不被视为服务中断，因为无论在哪种情况下，这些中断都是在内核运行时发生的。
  </para>

  <para>
   永远不会增补调用方。被调用方的 NOP 将替换为指向新函数的 JMP。JMP 指令会永久保留。这种工作方式可以处理好函数指针（包括结构中的指针），并且不需要保存任何旧数据就能取消增补。
  </para>

  <para>
   但是，这些步骤本身并不足够完善：因为函数将以非原子方式替换，内核某个部分中新修复的函数可能仍会调用其他位置的某个旧函数，反之亦然。如果函数接口的语义在增补程序中发生更改，将会造成混乱。
  </para>

  <para>
   因此，在替换所有函数之前，内核在线增补使用基于弹性机制且类似于 RCU（读取-复制-更新）的方案，来确保每个用户空间线程、内核线程和内核中断在全局视图中都保持一致。将对每个内核入口和出口设置一个基于线程的标志。这样，一个旧函数始终会调用另一个旧函数，而一个新函数始终会调用另一个新函数。为所有进程设置“new universe”标志后，增补即告完成，此时，可以去除弹簧床函数，代码可以全速运行，且不会对性能产生影响，不过，每个增补的函数需要经历超长时间的跳转。
  </para>
 </sect1>

  <sect1 xml:id="sec-klp-install-patch-activate">
   <title>激活 SLE Live Patching</title>
   <para>
    要在您的系统上激活 SLE Live Patching，请遵循以下步骤：
   </para>
   <procedure>
    <step>
     <para>
      您的 SLES 系统必须已注册。可以在系统安装期间注册该系统，也可以在安装后使用 YaST <guimenu>产品注册</guimenu>模块 (<command>yast2 registration</command>) 注册该系统。如果您的 SLES 系统已注册，但 SLE Live Patching 尚未激活，请运行 <command>yast2 registration</command> 命令，然后单击<guimenu>选择扩展</guimenu>。
     </para>
    </step>
    <step>
     <para>
      在可用扩展列表中选择 <guimenu>SUSE Linux Enterprise Live Patching 15</guimenu>，然后单击<guimenu>下一步</guimenu>。
     </para>
    </step>
    <step>
     <para>
      确认许可条款并单击<guimenu>下一步</guimenu>。
     </para>
    </step>
    <step>
     <para>
      输入您的 SLE Live Patching 注册代码并单击<guimenu>下一步</guimenu>。
     </para>
    </step>
    <step>
     <para>
      检查<guimenu>安装摘要</guimenu>和选定的<guimenu>模式</guimenu>。系统会为安装自动选择模式 <systemitem>Live Patching</systemitem> 和 <systemitem>SLE Live Patching Lifecycle Data</systemitem>，同时为满足依赖性可能还会选择安装一些其他包。 
     </para>
    </step>
    <step>
     <para>
      单击<guimenu>接受</guimenu>完成安装。也就是说，会在您的系统上安装基础内核在线增补组件、初始在线增补程序，以及任何依赖包。
     </para>
    </step>
   </procedure>
  </sect1>

  <sect1 xml:id="sec-klp-install-patch-update">
   <title>安装和去除增补程序</title>
   <para>
       本节介绍如何查找、安装和去除 KLP 增补程序。
   </para>
     <sect2 xml:id="sec-klp-install">
  <title>安装 KLP 增补程序</title>
     
   <procedure>
    <step>
     <para>
      在安装新的增补程序之前，请运行 <command>klp status</command> 命令查询当前状态，该状态必须是 <literal>ready</literal> 而不能是 <literal>in_progress</literal>。只有在完成前面的增补程序安装之后，才能应用新的增补程序。在唤醒并去除所有休眠进程前，都无法完全消除旧内核函数的调用。这可以节省大量的时间。但我们并不认为使用旧内核函数的休眠进程存在安全问题。（有关如何管理长时间 <literal>in_progress</literal> 状态的信息，请参见<xref linkend="sec-klp-exec-threads"/>。）
     </para>     
     </step>
    <step>
     <para>
         使用常规包管理系统 <command>zypper</command> 或 YaST 查看和安装可用的增补程序。以下示例将搜索可用的增补程序，然后安装最新的增补程序。不需要按顺序逐一安装所有增补程序；存在多个可用的增补程序时，只需要安装最新的增补程序。
     </para>
     <screen><prompt>tux &gt; </prompt><command>sudo</command> zypper se kernel-livepatch 
| kernel-livepatch-5_3_18-8_16-default  | Kernel live patch module  | package   
| kernel-livepatch-5_3_18-8_19-default  | Kernel live patch module  | package   
| kernel-livepatch-5_3_18-8_22-default  | Kernel live patch module  | package

<prompt>tux &gt; </prompt><command>sudo</command> zypper in kernel-livepatch-5_3_18-8_22-default</screen>     
    </step>
   </procedure>
  </sect2>
 
  <sect2 xml:id="sec-klp-remove">
  <title>去除 KLP 增补程序</title>
  <para>
      如果您需要去除某个 KLP 增补程序，请使用 <command>zypper</command>，就像去除任何其他包一样。使用 <command>zypper</command> 搜索 <literal>kernel-livepatch</literal>，列出已安装的在线增补程序包：
  </para>
     <screen><prompt>tux &gt; </prompt><command>sudo</command> zypper se -kernel-livepatch 
  | kernel-livepatch-5_3_18-8_16-default  | Kernel live patch module  | package   
  | kernel-livepatch-5_3_18-8_19-default  | Kernel live patch module  | package   
i | kernel-livepatch-5_3_18-8_22-default  | Kernel live patch module  | package
</screen>
  <procedure>
   <step>
    <para>
     使用 <command>zypper</command> 去除增补程序：
    </para>
<screen><prompt>tux &gt; </prompt><command>sudo</command> zypper rm kernel-livepatch-5_3_18-8_22-default</screen>
   </step>
   <step>
    <para>
     等待 <systemitem>initrd</systemitem> 自动重构建，然后重引导计算机。
    </para>
   </step>
  </procedure>
</sect2>
 </sect1>
 
  <sect1 xml:id="sec-klp-klp">
  <title><command>klp</command> 工具</title>

  <para>
   使用 <command>klp</command> 工具可以简化一些内核在线增补管理任务。可用的命令为：
  </para>

  <variablelist>
   <varlistentry>
    <term><command>klp status</command></term>
    <listitem>
     <para>
      显示内核在线增补的总体状态（<literal>ready</literal> 或 <literal>in_progress</literal>）。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>klp patches</command></term>
    <listitem>
     <para>
      显示已装载 KLP 增补程序的列表。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>klp blocking</command></term>
    <listitem>
     <para>
      列出阻止完成内核在线增补的进程。默认情况下，只会列出 PID。指定 <option>-v</option> 会列显命令行（如果有）。<option>-vv</option> 显示堆栈跟踪。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
  <para>
   有关详细信息，请参见 <command>man klp</command>。
  </para>
 </sect1>

 <sect1 xml:id="sec-klp-exec-threads">
  <title>阻塞的内核执行线程</title>

  <para>
   内核线程必须已准备好处理内核在线增补。第三方软件可能不支持内核在线增补，并可能会衍生内核执行线程。这些线程会无限期阻止增补过程。作为紧急应对措施，可以通过将 <literal>0</literal> 写入 <filename>/sys/kernel/livepatch/*/transition/</filename>（请将星号通配符替换为您的文件名），来强制完成增补进程，而不必等到所有执行线程都通过安全检查点。在执行此过程之前，请先咨询 SUSE 支持人员。
  </para>
</sect1>

 <sect1 xml:id="sec-klp-lifecycle">
  <title>增补程序生命周期</title>

  <para>
   可以使用 <command>zypper lifecycle</command> 来查看在线增补程序的失效日期。(确保包
   <package>lifecycle-data-sle-module-live-patching</package> 已安装。）
  </para>

  <para>
   当到了增补程序的失效日期时，将不再提供此内核版本的更多在线增补程序。请在在线增补程序生命周期期限结束之前规划内核更新。
  </para>

  <para>
   有关 <command>zypper lifecycle</command> 的细节，请参见《<emphasis>管理员指南</emphasis>》中的“<emphasis>显示生命周期信息</emphasis>”。
  </para>
 </sect1>

 <sect1 xml:id="sec-klp-scope">
  <title>内核在线增补技术的范围</title>

  <para>
   内核在线增补基于函数替换。数据结构的改动只能通过内核在线增补间接完成。因此，更改内核数据结构时需要特别小心，如果更改幅度太大，可能需要重引导。此外，对于使用一个编译器来编译旧内核而使用另一个编译器来编译增补程序的情况，内核在线增补可能无法处理。
  </para>

  <para>
   由于内核在线增补的工作方式，对衍生大量内核线程的第三方模块的支持有限。

  </para>
 </sect1>
 <sect1 xml:id="sec-klp-scope-patching">
  <title>SLE Live Patching 的应用范围</title>

  <para>
   SLE Live Patching 的应用范围包括 SUSE 通用漏洞评分系统（CVSS；SUSE CVSS 基于 CVSS v3.0 系统）级别 7 以上漏洞的修复，以及与系统稳定性或数据损坏相关的 Bug 修复。可能无法针对满足上述所有准则的所有修复类型生成在线增补程序。如果出于技术原因而无法生成内核在线增补程序，SUSE 有权不发布修复。有关作为 SUSE CVSS 评级基础的 CVSS 的详细信息，请参见 <link xlink:href="https://www.first.org/cvss/"/>。
  </para>
 </sect1>
 <sect1 xml:id="sec-klp-support-interaction">
  <title>使用支持流程与我们交互</title>

  <para>
   在与 SUSE 支持人员共同解决技术难题时，您可能会收到一个程序临时修复 (PTF)。我们可能会针对各种包（包括构成 SLE Live Patching 基础的包）发布 PTF。
  </para>

  <para>
   您可以像平时一样安装符合上一节中所述条件的内核在线增补 PTF，SUSE 将确保无需重引导有问题的系统，并且将来的在线更新可以正常应用。
  </para>

  <para>
   针对基础内核发布的 PTF 会中断在线增补过程。首先，安装 PTF 内核意味着需要重引导，因为在运行时无法替换整个内核。其次，需要再次重引导，以便将 PTF 替换为对其发布了在线增补程序的任何常规维护更新。
  </para>

  <para>
   可将 SLE Live Patching 中其他包的 PTF 视为享有正常担保的常规 PTF。
  </para>
 </sect1>
</chapter>
