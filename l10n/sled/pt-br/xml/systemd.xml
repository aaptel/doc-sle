<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="systemd.xml" version="5.0" xml:id="cha-systemd">
 <title>O daemon <systemitem class="daemon">systemd</systemitem></title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>yes (sim)</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  O programa <systemitem class="daemon">systemd</systemitem> tem ID de processo 1. Ele é responsável por inicializar o sistema da forma exigida. O <systemitem class="daemon">systemd</systemitem> é iniciado diretamente pelo kernel e resiste ao sinal 9, que normalmente termina os processos. Todos os outros programas são iniciados diretamente pelo systemd ou por um de seus processos filho.
 </para>
 <para>
  O Systemd é um substituto do daemon init do System V. O <systemitem class="daemon">systemd</systemitem> é totalmente compatível com o init do System V (pois suporta scripts init). Uma das principais vantagens do systemd é que ele acelera consideravelmente o tempo de boot, devido à sua capacidade agressiva de paralelização para iniciar serviços. Além disso, o systemd apenas inicia um serviço quando é realmente necessário. Os daemons não são iniciados incondicionalmente no momento da inicialização, mas, em vez disso, quando são solicitados pela primeira vez. O systemd também suporta Grupos de Controle do Kernel (cgroups), criação de instantâneos, restauração do estado do sistema, etc. Consulte a <link xlink:href="http://www.freedesktop.org/wiki/Software/systemd/"/> para obter os detalhes. 
 </para>

 <sect1 xml:id="sec-boot-systemd-concept">
  <title>O conceito do systemd</title>

  <para>
   Esta seção apresenta detalhes sobre o conceito que rege o systemd.
  </para>

  <sect2 xml:id="sec-boot-systemd-whatissystemd">
   <title>O que é systemd</title>
   <para>
    O systemd é um gerenciador de sistema e sessão para Linux, compatível com os scripts init do System V e do LSB. Os principais recursos são:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      capacidade agressiva de paralelização
     </para>
    </listitem>
    <listitem>
     <para>
      uso de soquete e ativação por D-Bus para iniciar serviços
     </para>
    </listitem>
    <listitem>
     <para>
      capacidade de iniciar daemons sob demanda
     </para>
    </listitem>
    <listitem>
     <para>
      acompanhamento de processos usando cgroups do Linux
     </para>
    </listitem>
    <listitem>
     <para>
      suporte à criação de instantâneos e restauração do estado do sistema
     </para>
    </listitem>
    <listitem>
     <para>
      manutenção dos pontos de montagem e automount
     </para>
    </listitem>
    <listitem>
     <para>
      implementação de uma lógica elaborada de controle de serviço baseada em dependência transacional
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-unitfile">
   <title>Arquivo unit</title>
   <para>
    O arquivo de configuração unit contém informações sobre serviço, soquete, dispositivo, ponto de montagem, ponto de automount, arquivo de troca (swap) ou partição, destino de inicialização, caminho do sistema de arquivos monitorado, temporizador controlado e supervisionado pelo systemd, instantâneo de estado do sistema temporário, fração de gerenciamento de recursos ou grupo de processos criados externamente. O <quote>arquivo unit</quote> é um termo genérico usado pelo systemd para o seguinte:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <formalpara>
      <title>Serviço</title>
      <para>
       Informações sobre um processo (por exemplo, a execução de um daemon); o arquivo termina com .service
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Destinos</title>
      <para>
       Usado para agrupar unidades e como pontos de sincronização durante a inicialização; o arquivo termina com .target
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Soquetes</title>
      <para>
       Informações sobre um soquete de rede, IPC ou FIFO do sistema de arquivos, para ativação baseada em soquete (como <systemitem class="daemon">inetd</systemitem>); o arquivo termina com .socket
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Caminho</title>
      <para>
       Usado para acionar outras unidades (por exemplo, executar um serviço quando houver mudanças nos arquivos); o arquivo termina com .path
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Timer</title>
      <para>
       Informações sobre um temporizador controlado, para ativação baseada em temporizador; o arquivo termina com .timer
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Ponto de montagem</title>
      <para>
       Normalmente, gerado de forma automática pelo gerador fstab; o arquivo termina com .mount
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Ponto de automount</title>
      <para>
       Informações sobre um ponto de automount do sistema de arquivos; o arquivo termina com .automount
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Swap</title>
      <para>
       Informações sobre um dispositivo ou arquivo de troca para paginação de memória; o arquivo termina com .swap
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Dispositivo</title>
      <para>
       Informações sobre uma unidade de dispositivo conforme exposta na árvore de dispositivos do sysfs/udev(7); o arquivo termina com .device
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Escopo/Fração</title>
      <para>
       Um conceito de gerenciamento hierárquico de recursos de um grupo de processos; o arquivo termina com .scope/.slice
      </para>
     </formalpara>
    </listitem>
   </itemizedlist>
   <para>
    Para obter mais informações sobre o systemd.unit, consulte <link xlink:href="http://www.freedesktop.org/software/systemd/man/systemd.unit.html"/>
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-basics">
  <title>Uso básico</title>

  <para>
   O sistema init do System V usa vários comandos para gerenciar serviços: scripts init, <command>insserv</command>, <command>telinit</command> e outros. O systemd facilita gerenciar serviços, já que existe apenas um comando para memorizar para a maioria das tarefas de gerenciamento de serviços: <command>systemctl</command>. Ele usa a notação <quote>command plus subcommand</quote>, como <command>git</command> ou <command>zypper</command>:
  </para>

<screen>systemctl <replaceable>GENERAL OPTIONS</replaceable> <replaceable>SUBCOMMAND</replaceable> <replaceable>SUBCOMMAND OPTIONS</replaceable></screen>

  <para>
   Consulte <command>man 1 systemctl</command> para obter o manual completo.
  </para>

  <tip>
   <title>Saída de terminal e complementação bash</title>
   <para>
    Se a saída chegar a um terminal (e não a um pipe ou arquivo, por exemplo), por padrão, os comandos systemd enviarão uma saída extensa para um pager. Use a opção <option>--no-pager</option> para desativar o modo de paginação.
   </para>
   <para>
    O systemd também suporta a complementação bash, que permite digitar as primeiras letras de um subcomando e pressionar <keycap function="tab"/> para completá-lo automaticamente. Esse recurso está disponível apenas no shell <systemitem>bash</systemitem> e requer a instalação do pacote <systemitem class="resource">bash-completion</systemitem>.
   </para>
  </tip>

  <sect2 xml:id="sec-boot-systemd-basics-services">
   <title>Gerenciando serviços em um sistema em execução</title>
   <para>
    Os subcomandos de gerenciamento de serviços são os mesmos usados para gerenciar um serviço com o init do System V (<command>start</command>, <command>stop</command>, etc.). A sintaxe geral dos comandos de gerenciamento de serviços é a seguinte:
   </para>
   <variablelist>
    <varlistentry>
     <term>systemd</term>
     <listitem>
<screen>systemctl reload|restart|start|status|stop|<replaceable>...</replaceable> <replaceable>MY_SERVICE(S)</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Init do System V</term>
     <listitem>
<screen>rc<replaceable>MY_SERVICE(S)</replaceable> reload|restart|start|status|stop|<replaceable>...</replaceable></screen>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    O systemd permite gerenciar vários serviços de uma só vez. Em vez de executar os scripts init um após o outro como acontece com o init do System V, execute um comando da seguinte forma:
   </para>
<screen><prompt>tux &gt; </prompt><command>sudo</command> systemctl start <replaceable>MY_1ST_SERVICE</replaceable> <replaceable>MY_2ND_SERVICE</replaceable></screen>
   <para>
    Para listar todos os serviços disponíveis no sistema:
   </para>
<screen><prompt>tux &gt; </prompt><command>sudo</command> systemctl list-unit-files --type=service</screen>
   <para>
    A tabela a seguir lista os comandos de gerenciamento de serviços mais importantes para o systemd e o init do System V:
   </para>
   <table rowsep="1">
    <title>Comandos de gerenciamento de serviços</title>
    <tgroup cols="3">
     <colspec colnum="1" colname="1" colwidth="50*"/>
     <colspec colnum="2" colname="2" colwidth="30*"/>
     <colspec colnum="3" colname="3" colwidth="20*"/>
     <thead>
      <row>
       <entry colname="1">
        <para>
         Tarefa
        </para>
       </entry>
       <entry colname="2">
        <para>
         Comando systemd
        </para>
       </entry>
       <entry colname="3">
        <para>
         Comando init do System V
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Iniciando</title>
         <para/>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>start</screen>
       </entry>
       <entry colname="3">
<screen>start</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Parar</title>
         <para/>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>stop</screen>
       </entry>
       <entry colname="3">
<screen>stop</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Reiniciar</title>
         <para>
          Encerra os serviços e os inicia na sequência. Se algum serviço ainda não estiver em execução, ele será iniciado.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>restart</screen>
       </entry>
       <entry colname="3">
<screen>restart</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Reiniciar condicionalmente</title>
         <para>
          Reinicia os serviços se já estiverem em execução. Não faz nada para os serviços que não estão em execução.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>try-restart</screen>
       </entry>
       <entry colname="3">
<screen>try-restart</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Recarregar</title>
         <para>
          Instrui os serviços a recarregarem seus arquivos de configuração sem interromper a operação. Caso de uso: Instruir o Apache a recarregar um arquivo de configuração <filename>httpd.conf</filename> modificado. Observe que nem todos os serviços suportam recarregamento.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload</screen>
       </entry>
       <entry colname="3">
<screen>reload</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Recarregar ou reiniciar</title>
         <para>
          Recarrega os serviços quando o recarregamento é suportado; do contrário, reinicia-os. Se algum serviço ainda não estiver em execução, ele será iniciado.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload-or-restart</screen>
       </entry>
       <entry colname="3">
<screen>n/a</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Recarregar ou reiniciar condicionalmente</title>
         <para>
          Recarrega os serviços se o recarregamento for suportado; do contrário reinicia-os, se estiverem em execução. Não faz nada para os serviços que não estão em execução.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>reload-or-try-restart</screen>
       </entry>
       <entry colname="3">
<screen>n/a</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Obter informações detalhadas sobre status</title>
         <para>
          Lista as informações sobre o status dos serviços. O comando <systemitem class="daemon">systemd</systemitem> mostra detalhes, como descrição, executável, status, cgroup e as últimas mensagens emitidas por um serviço (consulte a <xref linkend="sec-boot-systemd-basics-services-debugging"/>). O nível dos detalhes exibidos com o init do System V varia de acordo com cada serviço.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>status</screen>
       </entry>
       <entry colname="3">
<screen>status</screen>
       </entry>
      </row>
      <row>
       <entry colname="1">
        <formalpara>
         <title>Obter informações resumidas sobre status</title>
         <para>
          Mostra se os serviços estão ou não ativos.
         </para>
        </formalpara>
       </entry>
       <entry colname="2">
<screen>is-active</screen>
       </entry>
       <entry colname="3">
<screen>status</screen>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-basics-services-enabling">
   <title>Habilitando/Desabilitando serviços permanentemente</title>
   <para>
    Os comandos de gerenciamento de serviços mencionados na seção anterior permitem manipular serviços na seção atual. O systemd também permite habilitar ou desabilitar serviços permanentemente para serem iniciados automaticamente quando solicitados ou para ficarem sempre indisponíveis. É possível fazer isso com o YaST ou por linha de comando.
   </para>
   <sect3 xml:id="sec-boot-systemd-basics-services-enabling-cmd">
    <title>Habilitar/Desabilitar serviços na linha de comando</title>
    <para>
     A tabela a seguir lista os comandos de habilitação e desabilitação pelo systemd e pelo init do System V:
    </para>
    <important>
     <title>Inicialização de serviço</title>
     <para>
      Ao habilitar um serviço na linha de comando, ele não é iniciado automaticamente. Ele é programado para iniciar na próxima inicialização do sistema ou mudança de nível de execução/destino. Para iniciar um serviço logo após habilitá-lo, execute explicitamente <command>systemctl start <replaceable>MEU_SERVIÇO</replaceable></command> ou <command>rc <replaceable>MEU_SERVIÇO</replaceable> start</command>.
     </para>
    </important>
    <table rowsep="1">
     <title>Comandos para habilitar e desabilitar serviços</title>
     <tgroup cols="3">
      <colspec colnum="1" colname="1" colwidth="32*"/>
      <colspec colnum="2" colname="2" colwidth="40*"/>
      <colspec colnum="3" colname="3" colwidth="28*"/>
      <thead>
       <row>
        <entry colname="1">
         <para>
          Tarefa
         </para>
        </entry>
        <entry colname="2">
         <para>
          <systemitem class="daemon">Comando systemd</systemitem>
         </para>
        </entry>
        <entry colname="3">
         <para>
          Comando init do System V
         </para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Habilitar</title>
          <para/>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl enable <replaceable>MEU(S)_SERVIÇO(S)</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>insserv <replaceable>MEU(S)_SERVIÇO(S)</replaceable></command>, <command>chkconfig -a <replaceable>MEU(S)_SERVIÇO(S)</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Desabilitar</title>
          <para/>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl disable <replaceable>MEU(S)_SERVIÇO(S)</replaceable>.service</command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>insserv -r <replaceable>MEU(S)_SERVIÇO(S)</replaceable></command>, <command>chkconfig -d <replaceable>MEU(S)_SERVIÇO(S)</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Verificar</title>
          <para>
           Mostra se um serviço está ou não habilitado.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl is-enabled <replaceable>MEU_SERVIÇO</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>chkconfig <replaceable>MEU_SERVIÇO</replaceable></command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Reabilitar</title>
          <para>
           Semelhante a reiniciar um serviço, este comando primeiro desabilita e depois habilita um serviço. Útil para restaurar um serviço aos seus padrões.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl reenable <replaceable>MEU_SERVIÇO</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/d
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Mascarar</title>
          <para>
           Após <quote>desabilitar</quote> um serviço, ele ainda poderá ser iniciado manualmente. Para desabilitar um serviço completamente, é necessário mascará-lo. Use com cuidado.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl mask <replaceable>MEU_SERVIÇO</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/d
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <formalpara>
          <title>Desmascarar</title>
          <para>
           Só será possível usar novamente um serviço mascarado depois que ele for desmascarado.
          </para>
         </formalpara>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl unmask <replaceable>MEU_SERVIÇO</replaceable></command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/d
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-boot">
  <title>Inicialização do sistema e gerenciamento de destino</title>

  <para>
   Todo o processo de inicialização e encerramento do sistema é mantido pelo systemd. Desse ponto de vista, o kernel pode ser considerado um processo em segundo plano para manter todos os outros processos e ajustar o horário da CPU e o acesso ao hardware de acordo com as solicitações de outros programas.
  </para>

  <sect2 xml:id="sec-boot-systemd-targets">
   <title>Comparação entre destinos e níveis de execução</title>
   <para>
    Com o init do System V, o sistema era inicializado no chamado <quote>Nível de execução</quote>. O nível de execução define como o sistema é iniciado e quais serviços estão disponíveis no sistema em execução. Os níveis de execução são numerados: os mais conhecidos são <literal>0</literal> (encerramento do sistema), <literal>3</literal> (multiusuário com rede) e <literal>5</literal> (multiusuário com rede e gerenciador de exibição).
   </para>
   <para>
    O systemd apresenta um novo conceito usando as chamadas <quote>unidades de destino</quote>. No entanto, ele continua totalmente compatível com o conceito de nível de execução. As unidades de destino são nomeadas, e não numeradas, e possuem finalidades específicas. Por exemplo, os destinos <systemitem>local-fs.target</systemitem> e <systemitem>swap.target</systemitem> montam sistemas de arquivos locais e espaços de troca.
   </para>
   <para>
    O destino <systemitem>graphical.target</systemitem> oferece recursos de sistema multiusuário com rede e gerenciador de exibição e equivale ao nível de execução 5. Destinos complexos, como <systemitem>graphical.target</systemitem>, agem como destinos <quote>meta</quote>, combinando um subconjunto de outros destinos. Como o systemd facilita criar destinos personalizados combinando destinos existentes, ele oferece excelente flexibilidade.
   </para>
   <para>
    A lista a seguir mostra as unidades de destino mais importantes do systemd. Para ver a lista completa, consulte <command>man 7 systemd.special</command>.
   </para>
   <variablelist>
    <title>Unidades de destino selecionadas do systemd</title>
    <varlistentry>
     <term><systemitem>default.target</systemitem>
     </term>
     <listitem>
      <para>
       O destino que é inicializado por padrão. Não um destino <quote>real</quote>, mas um link simbólico para outro destino, como <systemitem>graphic.target</systemitem>. Pode ser modificado permanentemente pelo YaST (consulte a <xref linkend="sec-boot-runlevel-edit"/>). Para mudá-lo em uma sessão, use o parâmetro do kernel <literal>systemd.unit=<replaceable>MEU_DESTINO.destino</replaceable></literal> no prompt de boot.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>emergency.target</systemitem>
     </term>
     <listitem>
      <para>
       Inicia o shell de emergência no console. Use-o apenas no prompt de boot como <literal>systemd.unit=emergency.target</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>graphical.target</systemitem>
     </term>
     <listitem>
      <para>
       Inicia um sistema com suporte a rede multiusuário e um gerenciador de exibição.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>halt.target</systemitem>
     </term>
     <listitem>
      <para>
       Encerra o sistema.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>mail-transfer-agent.target</systemitem>
     </term>
     <listitem>
      <para>
       Inicia todos os serviços necessários para enviar e receber e-mails.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>multi-user.target</systemitem>
     </term>
     <listitem>
      <para>
       Inicia um sistema multiusuário com rede.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>reboot.target</systemitem>
     </term>
     <listitem>
      <para>
       Reinicializa o sistema.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><systemitem>rescue.target</systemitem>
     </term>
     <listitem>
      <para>
       Inicia um sistema de usuário único sem rede.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Para continuar compatível com o sistema de nível de execução init do System V, o systemd oferece destinos especiais chamados <literal>runlevel<replaceable>X</replaceable>.target</literal> mapeados a níveis de execução correspondentes numerados <replaceable>X</replaceable>.
   </para>
   <para>
    Para saber o destino atual, use o comando: <command>systemctl get-default</command>
   </para>
   <table rowsep="1">
    <title>Níveis de execução do System V e unidades de destino do <systemitem class="daemon">systemd</systemitem></title>
    <tgroup cols="3">
     <colspec colnum="1" colname="1" colwidth="20*"/>
     <colspec colnum="2" colname="2" colwidth="40*"/>
     <colspec colnum="3" colname="3" colwidth="40*"/>
     <thead>
      <row>
       <entry>
        <para>
         Nível de execução do System V
        </para>
       </entry>
       <entry>
        <para>
         Destino do <systemitem class="daemon">systemd</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         Finalidade
        </para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>
         0
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel0.target</systemitem>, <systemitem>halt.target</systemitem>, <systemitem>poweroff.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         Encerramento do sistema
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         1, S
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel1.target</systemitem>, <systemitem>rescue.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Modo de usuário único
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         2
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel2.target</systemitem>, <systemitem>multi-user.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Multiusuário local sem rede remota
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         3
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel3.target</systemitem>, <systemitem>multi-user.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Multiusuário completo com rede
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         4
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel4.target</systemitem>
        </para>
       </entry>
       <entry>
        <para>
         Não usado/Definido pelo usuário
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         5
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel5.target</systemitem>, <systemitem>graphical.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Multiusuário completo com rede e gerenciador de exibição
        </para>
       </entry>
      </row>
      <row>
       <entry>
        <para>
         6
        </para>
       </entry>
       <entry>
        <para>
         <systemitem>runlevel6.target</systemitem>, <systemitem>reboot.target</systemitem>,
        </para>
       </entry>
       <entry>
        <para>
         Reinicialização do sistema
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <important>
    <title>O systemd ignora o <filename>/etc/inittab</filename></title>
    <para>
     Os níveis de execução em um sistema init do System V são configurados em <filename>/etc/inittab</filename>. O systemd <emphasis>não</emphasis> usa essa configuração. Consulte a <xref linkend="sec-boot-systemd-custom-targets"/> para obter instruções sobre como criar seu próprio destino inicializável.
    </para>
   </important>
   <sect3 xml:id="sec-boot-systemd-targets-commands">
    <title>Comandos para mudar os destinos</title>
    <para>
     Use os seguintes comandos para operar com unidades de destino:
    </para>
    <informaltable rowsep="1">
     <tgroup cols="3">
      <colspec colnum="1" colname="1" colwidth="20*"/>
      <colspec colnum="2" colname="2" colwidth="50*"/>
      <colspec colnum="3" colname="3" colwidth="30*"/>
      <thead>
       <row>
        <entry colname="1">
         <para>
          Tarefa
         </para>
        </entry>
        <entry colname="2">
         <para>
          Comando systemd
         </para>
        </entry>
        <entry colname="3">
         <para>
          Comando init do System V
         </para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry colname="1">
         <para>
          Mudar o destino/nível de execução atual
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl isolate</command> <replaceable>MEU_DESTINO</replaceable>.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>telinit</command> <replaceable>X</replaceable>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Mudar para o destino/nível de execução padrão
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl default</command>
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/d
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Obter o destino/nível de execução atual
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl list-units --type=target</command>
         </para>
         <para>
          Com o systemd, normalmente há mais de um destino ativo. O comando lista todos os destinos que estão ativos.
         </para>
        </entry>
        <entry colname="3">
         <para>
          <command>who -r</command>
         </para>
         <para>
          ou
         </para>
         <para>
          <command>runlevel</command>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Mudar o nível de execução padrão de forma persistente
         </para>
        </entry>
        <entry colname="2">
         <para>
          Use o Gerenciador de Serviços ou execute o seguinte comando:
         </para>
         <para>
          <command>Em -sf /usr/lib/systemd/system/</command> <replaceable>MEU_DESTINO</replaceable>.target /etc/systemd/system/default.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          Use o Gerenciador de Serviços ou mude a linha
         </para>
         <para>
          <command>id:</command><replaceable>X</replaceable>:initdefault:
         </para>
         <para>
          em <filename>/etc/inittab</filename>
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Mudar o nível de execução padrão para o processo de boot atual
         </para>
        </entry>
        <entry colname="2">
         <para>
          Digite a seguinte opção no prompt de boot
         </para>
         <para>
          <command>systemd.unit=</command> <replaceable>MEU_DESTINO</replaceable>.target
         </para>
        </entry>
        <entry colname="3">
         <para>
          Digite o número do nível de execução desejado no prompt de boot.
         </para>
        </entry>
       </row>
       <row>
        <entry colname="1">
         <para>
          Mostrar as dependências de um destino/nível de execução
         </para>
        </entry>
        <entry colname="2">
         <para>
          <command>systemctl show -p "Requires"</command> <replaceable>MEU_DESTINO</replaceable>.target
         </para>
         <para>
          <command>systemctl show -p "Wants"</command> <replaceable>MEU_DESTINO</replaceable>.target
         </para>
         <para>
          <quote>Requires</quote> lista as dependências obrigatórias (hard) (aquelas que devem ser resolvidas), enquanto <quote>Wants</quote> lista as dependências desejadas (soft) (aquelas que são resolvidas quando possível).
         </para>
        </entry>
        <entry colname="3">
         <para>
          n/d
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-debug">
   <title>Depurando a inicialização do sistema</title>
   <para>
    O systemd oferece os meios para a análise dos processos de inicialização do sistema. É possível revisar a lista de todos os serviços e os respectivos status (em vez de analisar o <filename>/var/log/</filename>). O systemd permite também explorar o procedimento de inicialização para descobrir quanto tempo leva para inicializar cada serviço.
   </para>
   <sect3 xml:id="sec-boot-systemd-debug-review">
    <title>Revisar inicialização dos serviços</title>
    <para>
     Para revisar a lista completa dos serviços que foram iniciados desde a inicialização do sistema, digite o comando <command>systemctl</command>. Ele lista todos os serviços ativos, conforme mostrado a seguir (resumidamente). Para obter mais informações sobre determinado serviço, use <command>systemctl status <replaceable>MEU_SERVIÇO</replaceable></command>.
    </para>
    <example>
     <title>Listar serviços ativos</title>
<screen><prompt role="root">root # </prompt>systemctl
UNIT                        LOAD   ACTIVE SUB       JOB DESCRIPTION
[...]
iscsi.service               loaded active exited    Login and scanning of iSC+
kmod-static-nodes.service   loaded active exited    Create list of required s+
libvirtd.service            loaded active running   Virtualization daemon
nscd.service                loaded active running   Name Service Cache Daemon
chronyd.service             loaded active running   NTP Server Daemon
polkit.service              loaded active running   Authorization Manager
postfix.service             loaded active running   Postfix Mail Transport Ag+
rc-local.service            loaded active exited    /etc/init.d/boot.local Co+
rsyslog.service             loaded active running   System Logging Service
[...]
LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.

161 loaded units listed. Pass --all to see loaded but inactive units, too.
To show all installed unit files use 'systemctl list-unit-files'.</screen>
    </example>
    <para>
     Para restringir o resultado a serviços com falha na inicialização, use a opção <option>--failed</option>:
    </para>
    <example>
     <title>Listar serviços com falha</title>
<screen><prompt role="root">root # </prompt>systemctl --failed
UNIT                   LOAD   ACTIVE SUB    JOB DESCRIPTION
apache2.service        loaded failed failed     apache
NetworkManager.service loaded failed failed     Network Manager
plymouth-start.service loaded failed failed     Show Plymouth Boot Screen

[...]</screen>
    </example>
   </sect3>
   <sect3 xml:id="sec-boot-systemd-debug-time">
    <title>Depurar o tempo de inicialização</title>
    <para>
     Para depurar o tempo de inicialização do sistema, o systemd oferece o comando <command>systemd-analyze. </command> Ele mostra o tempo total de inicialização, uma lista dos serviços solicitados por tempo de inicialização e também gera um gráfico SVG mostrando o tempo que os serviços levaram para serem iniciados em relação a outros serviços.
    </para>
    <variablelist>
     <varlistentry>
      <term>Listando o tempo de inicialização do sistema</term>
      <listitem>
<screen><prompt role="root">root # </prompt>systemd-analyze
Startup finished in 2666ms (kernel) + 21961ms (userspace) = 24628ms</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Listando o tempo de inicialização dos serviços</term>
      <listitem>
<screen><prompt role="root">root # </prompt>systemd-analyze blame
    15.000s backup-rpmdb.service
    14.879s mandb.service
     7.646s backup-sysconfig.service
     4.940s postfix.service
     4.921s logrotate.service
     4.640s libvirtd.service
     4.519s display-manager.service
     3.921s btrfsmaintenance-refresh.service
     3.466s lvm2-monitor.service
     2.774s plymouth-quit-wait.service
     2.591s firewalld.service
     2.137s initrd-switch-root.service
     1.954s ModemManager.service
     1.528s rsyslog.service
     1.378s apparmor.service
    [...]
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Gráficos do tempo de inicialização dos serviços</term>
      <listitem>
<screen><prompt role="root">root # </prompt>systemd-analyze plot &gt; jupiter.example.com-startup.svg</screen>
       <informalfigure>
        <mediaobject>
         <imageobject role="fo">
          <imagedata fileref="systemd_startup.svg" width="75%" format="SVG"/>
         </imageobject>
         <imageobject role="html">
          <imagedata fileref="systemd_startup.png" width="75%" format="PNG"/>
         </imageobject>
        </mediaobject>
       </informalfigure>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="sec-boot-systemd-debug-complete">
    <title>Revisar o processo de inicialização completo</title>
    <para>
     Os comandos mencionados anteriormente permitem revisar os serviços que foram iniciados e o tempo que levou para iniciá-los. Se você precisar de mais detalhes, poderá instruir o <systemitem class="daemon">systemd</systemitem> a registrar de forma verbosa o procedimento de inicialização completo, digitando os seguintes parâmetros no prompt de boot:
    </para>
<screen>systemd.log_level=debug systemd.log_target=kmsg</screen>
    <para>
     Agora o <systemitem class="daemon">systemd</systemitem> grava suas mensagens de registro no buffer de anel do kernel. Veja esse buffer com <command>dmesg</command>:
    </para>
<screen><prompt>tux &gt; </prompt>dmesg -T | less</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-sysv-compatibility">
   <title>Compatibilidade com o System V</title>
   <para>
    O systemd é compatível com o System V, o que ainda permite usar os scripts init existentes do System V. Entretanto, há pelo menos um problema conhecido em que o script init do System V não funciona com o systemd out-of-the-box: iniciar um serviço como outro usuário por meio de <command>su</command> ou <command>sudo</command> nos scripts init resulta em falha do script, gerando um erro de <quote>Acesso negado</quote>.
   </para>
   <para>
    Ao mudar o usuário com <command>su</command> ou <command>sudo</command>, é iniciada uma sessão PAM. Essa sessão será terminada após a conclusão do script init. Como consequência, o serviço que foi iniciado pelo script init também será terminado. Para solucionar esse erro, faça o seguinte:
   </para>
   <procedure>
    <step>
     <para>
      Crie um agrupador de arquivo de serviço com o mesmo nome do script init e mais a extensão de nome de arquivo <filename>.service</filename>:
     </para>
<screen>[Unit]
Description=<replaceable>DESCRIPTION</replaceable>
After=network.target

[Service]
User=<replaceable>USER</replaceable>
Type=forking<co xml:id="co-service-wrapper-type"/>
PIDFile=<replaceable>PATH TO PID FILE</replaceable><xref linkend="co-service-wrapper-type" xrefstyle="select:label nopage"/>
ExecStart=<replaceable>PATH TO INIT SCRIPT</replaceable> start
ExecStop=<replaceable>PATH TO INIT SCRIPT</replaceable> stop
ExecStopPost=/usr/bin/rm -f <replaceable>PATH TO PID FILE</replaceable><xref linkend="co-service-wrapper-type" xrefstyle="select:label nopage"/>

[Install]
WantedBy=multi-user.target<co xml:id="co-service-wrapper-target"/></screen>
     <para>
      Substitua todos os valores gravados em <replaceable>LETRAS MAIÚSCULAS</replaceable> pelos valores apropriados.
     </para>
     <calloutlist>
      <callout arearefs="co-service-wrapper-type">
       <para>
        Opcional: use apenas se o script init iniciar um daemon.
       </para>
      </callout>
      <callout arearefs="co-service-wrapper-target">
       <para>
        O <literal>multi-user.target</literal> também inicia o script init ao inicializar no <literal>graphical.target</literal>. Se ele tiver que ser iniciado apenas ao inicializar no gerenciador de exibição, use o <literal>graphical.target</literal> aqui.
       </para>
      </callout>
     </calloutlist>
    </step>
    <step>
     <para>
      Inicie o daemon com <command>systemctl start <replaceable>APLICATIVO</replaceable></command>.
     </para>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-runlevel-edit">
  <title>Gerenciando serviços com o YaST</title>

  <para>
   O gerenciamento básico de serviços também pode ser feito com o módulo Gerenciador de Serviços do YaST. Ele permite iniciar, parar, habilitar e desabilitar serviços. Ele permite também mostrar o status e mudar o destino padrão de um serviço. Inicie o módulo do YaST em <menuchoice> <guimenu>YaST</guimenu> <guimenu>Sistema</guimenu> <guimenu>Services Manager</guimenu> </menuchoice> (Gerenciador de Serviços).
  </para>

  <figure xml:id="fig-yast2-runlevel">
   <title>Gerenciador de Serviços</title>
   <mediaobject>
    <imageobject role="fo">
     <imagedata fileref="yast2_runlevel.png" width="75%" format="PNG"/>
    </imageobject>
    <imageobject role="html">
     <imagedata fileref="yast2_runlevel.png" width="75%" format="PNG"/>
    </imageobject>
   </mediaobject>
  </figure>

  <variablelist>
   <varlistentry>
    <term>Mudando o <guimenu>destino padrão do sistema</guimenu>
    </term>
    <listitem>
     <para>
      Para mudar o destino de inicialização do sistema, escolha o destino na caixa suspensa <guimenu>Default System Target</guimenu> (Destino Padrão do Sistema). Os destinos mais usados são <guimenu>Graphical Interface</guimenu> (Interface Gráfica) (iniciando uma tela gráfica de login) e <guimenu>Multiusuário</guimenu> (iniciando o sistema no modo de linha de comando).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Iniciando ou parando um serviço</term>
    <listitem>
     <para>
      Selecione um serviço da tabela. A coluna <guimenu>Ativo</guimenu> mostra se ele está em execução (<guimenu>Ativo</guimenu>) ou não (<guimenu>Inativo</guimenu>). Para alternar o status, escolha <guimenu>Iniciar/Parar</guimenu>.
     </para>
     <para>
      Quando um serviço é iniciado ou parado, seu status muda na sessão que está em execução. Para mudar seu status em todas as reinicializações, é necessário habilitá-lo ou desabilitá-lo.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Habilitando ou desabilitando um serviço</term>
    <listitem>
     <para>
      Selecione um serviço da tabela. A coluna <guimenu>Habilitado</guimenu> mostra se ele está <guimenu>Habilitado</guimenu> ou <guimenu>Desabilitado</guimenu>. Para alternar o status, escolha <guimenu>Habilitar/Desabilitar</guimenu>.
     </para>
     <para>
      Quando um serviço é habilitado ou desabilitado, você configura se ele deve ser iniciado durante a inicialização (<guimenu>Habilitado</guimenu>) ou não (<guimenu>Desabilitado</guimenu>). Essa configuração não afeta a sessão atual. Para mudar seu status na sessão atual, é necessário iniciá-lo ou pará-lo.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Ver mensagens de status</term>
    <listitem>
     <para>
      Para ver a mensagem de status de um serviço, selecione-o na lista e escolha <guimenu>Mostrar Detalhes</guimenu>. A saída exibida será idêntica a que foi gerada pelo comando <command>systemctl</command> <option>-l</option> status <replaceable>MEU_SERVIÇO</replaceable>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <warning>
   <title>Configurações de nível de execução defeituosas podem danificar o sistema</title>
   <para>
    Configurações de nível de execução defeituosas podem tornar o sistema inutilizável. Antes de aplicar as mudanças, tenha absoluta certeza sobre suas consequências.
   </para>
  </warning>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-custom">
  <title>Personalização do <systemitem>systemd</systemitem></title>

  <para>
   As seções a seguir mostram alguns exemplos de personalização do <systemitem>systemd</systemitem>.
  </para>

  <warning>
   <title>Evitando personalização sobregravada</title>
   <para>
    Faça sempre as personalizações do systemd em <filename>/etc/systemd/</filename>, <emphasis>nunca</emphasis> em <filename>/usr/lib/systemd/</filename>. Do contrário, as mudanças serão sobregravadas na próxima atualização do systemd.
   </para>
  </warning>

  <sect2 xml:id="sec-boot-systemd-custom-service">
   <title>Personalizando arquivos unit</title>
   <para>
    Os arquivos unit do systemd estão localizados em <filename>/usr/lib/systemd/system</filename>. Para personalizá-los, faça o seguinte:
   </para>
   <procedure>
    <step>
     <para>
      Copie os arquivos que deseja modificar de <filename>/usr/lib/systemd/system</filename> para <filename>/etc/systemd/system</filename>. Mantenha os mesmos nomes de arquivo dos originais.
     </para>
    </step>
    <step>
     <para>
      Modifique as cópias em <filename>/etc/systemd/system</filename> de acordo com as suas necessidades.
     </para>
    </step>
    <step>
     <para>
      Para obter uma visão geral das mudanças de configuração, use o comando <command>systemd-delta. </command> Ele compara e identifica os arquivos de configuração que anulam outros arquivos de configuração. Para obter detalhes, consulte a página de manual do <command>systemd-delta</command>.
     </para>
    </step>
   </procedure>
   <para>
    Os arquivos modificados em <filename>/etc/systemd</filename> terão prioridade sobre os arquivos originais em <filename>/usr/lib/systemd/system</filename>, desde que seus nomes sejam iguais.
   </para>
   <sect3 xml:id="systemd-xinetd-conversion">
    <title>Convertendo os serviços do <systemitem>xinetd</systemitem> em <systemitem class="daemon">systemd</systemitem></title>
    <para>
     Desde o lançamento do <phrase role="productname"><phrase os="sled">SUSE Linux Enterprise Desktop</phrase></phrase> 15, a infraestrutura do <systemitem>xinetd</systemitem> foi removida. Esta seção descreve como converter arquivos existentes de serviço do <systemitem>xinetd</systemitem> em soquetes do <systemitem class="daemon">systemd</systemitem>.
    </para>
    <para>
     Para cada arquivo de serviço do <systemitem>xinetd</systemitem>, você precisa de pelo menos dois arquivos unit do <systemitem class="daemon">systemd</systemitem>: o arquivo de soquete (<filename>*.socket</filename>) e um arquivo de serviço associado (<filename>*.service</filename>). O arquivo de soquete informa ao <systemitem class="daemon">systemd</systemitem> qual soquete criar, e o arquivo de serviço informa ao <systemitem class="daemon">systemd</systemitem> qual executável iniciar.
    </para>
    <para>
     Considere o seguinte arquivo de serviço do <systemitem>xinetd</systemitem> de exemplo:
    </para>
<screen><prompt role="root">root # </prompt>cat /etc/xinetd.d/example
service example
{
  socket_type = stream
  protocol = tcp
  port = 10085
  wait = no
  user = user
  group = users
  groups = yes
  server = /usr/libexec/example/exampled
  server_args = -auth=bsdtcp exampledump
  disable = no
}</screen>
    <para>
     Para convertê-lo em <systemitem class="daemon">systemd</systemitem>, você precisa dos dois arquivos correspondentes a seguir:
    </para>
<screen><prompt role="root">root # </prompt>cat /usr/lib/systemd/system/example.socket
[Socket]
ListenStream=0.0.0.0:10085
Accept=false

[Install]
WantedBy=sockets.target</screen>
<screen><prompt role="root">root # </prompt>cat /usr/lib/systemd/system/example.service
[Unit]
Description=example

[Service]
ExecStart=/usr/libexec/example/exampled -auth=bsdtcp exampledump
User=user
Group=users
StandardInput=socket
</screen>
    <para>
     Para obter uma lista completa das opções de arquivo de “soquete” e de “serviço” do <systemitem class="daemon">systemd</systemitem>, consulte as páginas de manual systemd.socket e systemd.service (<command>man 5 systemd.socket</command>, <command>man 5 systemd.service</command>).
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-custom-drop-in">
   <title>Criando arquivos <quote>dropin</quote></title>
   <para>
    Para adicionar apenas algumas linhas a um arquivo de configuração ou modificar uma pequena parte dele, é possível usar os chamados arquivos <quote>dropin. </quote> Esses arquivos permitem estender a configuração dos arquivos de unidade sem ter que editá-los ou anulá-los realmente.
   </para>
   <para>
    Por exemplo, para mudar um valor no serviço <replaceable>FOOBAR</replaceable> localizado em <filename>/usr/lib/systemd/system/<replaceable>SERVIÇO.FOOBAR</replaceable></filename>, faça o seguinte:
   </para>
   <procedure>
    <step>
     <para>
      Crie um diretório chamado <filename>/etc/systemd/system/<replaceable>FOOBAR</replaceable>.service.d/</filename>.
     </para>
     <para>
      Observe o sufixo <literal>.d. </literal> O diretório deve receber outro nome de acordo com o serviço que você deseja corrigir com o arquivo dropin.
     </para>
    </step>
    <step>
     <para>
      Nesse diretório, crie um arquivo <filename><replaceable>QUALQUERMODIFICAÇÃO</replaceable>.conf</filename>.
     </para>
     <para>
      Verifique se ele contém somente a linha com o valor que deseja modificar.
     </para>
    </step>
    <step>
     <para>
      Grave as mudanças feitas no arquivo Ele será usado como extensão do arquivo original.
     </para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-custom-targets">
   <title>Criando destinos personalizados</title>
   <para>
    Nos sistemas init SUSE do System V, o nível de execução 4 não costuma ser usado para permitir que administradores criem sua própria configuração de nível de execução. O systemd permite criar qualquer número de destinos personalizados. A sugestão é começar adaptando um destino existente, como <systemitem>graphical.target</systemitem>.
   </para>
   <procedure>
    <step>
     <para>
      Copie o arquivo de configuração <filename>/usr/lib/systemd/system/graphical.target</filename> para <filename>/etc/systemd/system/<replaceable>MEU_DESTINO</replaceable>.target</filename> e ajuste-o de acordo com as suas necessidades.
     </para>
    </step>
    <step>
     <para>
      O arquivo de configuração copiado na etapa anterior já inclui as dependências obrigatórias (<quote>hard</quote>) do destino. Para incluir também as dependências desejadas (<quote>soft</quote>), crie um diretório <filename>/etc/systemd/system/<replaceable>MEU_DESTINO</replaceable>.target.wants</filename>.
     </para>
    </step>
    <step>
     <para>
      Para cada serviço desejado, crie um link simbólico de <filename>/usr/lib/systemd/system</filename> para <filename>/etc/systemd/system/<replaceable>MEU_DESTINO</replaceable>.target.wants</filename>.
     </para>
    </step>
    <step>
     <para>
      Após concluir a configuração do destino, recarregue a configuração do systemd para disponibilizar o novo destino:
     </para>
<screen><prompt>tux &gt; </prompt><command>sudo</command> systemctl daemon-reload</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-advanced">
  <title>Uso avançado</title>

  <para>
   As seções a seguir abordam tópicos avançados para administradores do sistema. Para obter uma documentação ainda mais avançada do systemd, consulte a série de Lennart Pöttering sobre o systemd para administradores em <link xlink:href="http://0pointer.de/blog/projects"/>.
  </para>

  <sect2 xml:id="sec-boot-systemd-advanced-tmp">
   <title>Limpando diretórios temporários</title>
   <para>
    O <systemitem class="daemon">systemd</systemitem> suporta a limpeza de diretórios temporários regularmente. A configuração da versão do sistema anterior é automaticamente migrada e ativada. O <literal>tmpfiles.d</literal>, que é responsável por gerenciar arquivos temporários, lê sua configuração dos arquivos <filename>/etc/tmpfiles.d/*.conf</filename> , <filename>/run/tmpfiles.d/*.conf</filename> e <filename>/usr/lib/tmpfiles.d/*.conf. </filename> A configuração armazenada no <filename>/etc/tmpfiles.d/*.conf</filename> anula as configurações relacionadas dos outros dois diretórios (<filename>/usr/lib/tmpfiles.d/*.conf</filename> é o local onde os pacotes armazenam seus arquivos de configuração).
   </para>
   <para>
    O formato da configuração é de uma linha por caminho incluindo ação e caminho; e, opcionalmente, modo, propriedade e os campos de idade e argumento, dependendo da ação. O exemplo a seguir desvincula os arquivos de bloqueio do X11:
   </para>
<screen>Type Path               Mode UID  GID  Age Argument
r    /tmp/.X[0-9]*-lock</screen>
   <para>
    Para obter o status do temporizador tmpfile:
   </para>
<screen><prompt>tux &gt; </prompt><command>sudo</command> systemctl status systemd-tmpfiles-clean.timer
systemd-tmpfiles-clean.timer - Daily Cleanup of Temporary Directories
 Loaded: loaded (/usr/lib/systemd/system/systemd-tmpfiles-clean.timer; static)
 Active: active (waiting) since Tue 2018-04-09 15:30:36 CEST; 1 weeks 6 days ago
   Docs: man:tmpfiles.d(5)
         man:systemd-tmpfiles(8)

Apr 09 15:30:36 jupiter systemd[1]: Starting Daily Cleanup of Temporary Directories.
Apr 09 15:30:36 jupiter systemd[1]: Started Daily Cleanup of Temporary Directories.</screen>
   <para>
    Para obter mais informações sobre como lidar com os arquivos temporários, consulte <command>man 5 tmpfiles.d</command>.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-advanced-logging">
   <title>Registro do Sistema</title>
   <para>
    A <xref linkend="sec-boot-systemd-basics-services-debugging"/> explica como ver mensagens de registro de determinado serviço. No entanto, a exibição de mensagens de registro não se restringe a registros de serviços. É possível também acessar e consultar as mensagens de registro completas gravadas pelo <systemitem class="daemon">systemd</systemitem>, o chamado <quote>Diário</quote>. Use o comando <command>journalctl</command> para exibir as mensagens de registro completas começando pelas entradas mais antigas. Consulte <command>man 1 journalctl</command> para ver as opções. Por exemplo, aplicação de filtros ou mudança do formato de saída.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-advanced-snapshots">
   <title>Instantâneos</title>
   <para>
    É possível gravar o estado atual do <systemitem class="daemon">systemd</systemitem> em um instantâneo nomeado e mais tarde revertê-lo com o subcomando <command>isolate. </command> Isso é útil para testar serviços ou destinos personalizados, pois permite retornar para um estado definido a qualquer momento. Um instantâneo só fica disponível na sessão atual e é apagado automaticamente na reinicialização. O nome do instantâneo deve terminar com <filename>.snapshot</filename>.
   </para>
   <variablelist>
    <varlistentry>
     <term>Criar um instantâneo</term>
     <listitem>
<screen><prompt>tux &gt; </prompt><command>sudo</command> systemctl snapshot <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Apagar um instantâneo</term>
     <listitem>
<screen><prompt>tux &gt; </prompt><command>sudo</command> systemctl delete <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Ver um instantâneo</term>
     <listitem>
<screen><prompt>tux &gt; </prompt><command>sudo</command> systemctl show <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Ativar um instantâneo</term>
     <listitem>
<screen><prompt>tux &gt; </prompt><command>sudo</command> systemctl isolate <replaceable>MY_SNAPSHOT</replaceable>.snapshot</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>





  <sect2 xml:id="sec-boot-systemd-advanced-kernel-modules">
   <title>Carregamento de Módulos do Kernel</title>
   <para>
    Com o <systemitem class="daemon">systemd</systemitem>, é possível carregar os módulos do kernel automaticamente no momento da inicialização, usando o arquivo de configuração em <filename>/etc/modules-load.d</filename>. O arquivo deve ser nomeado <replaceable>MÓDULO</replaceable>.conf e ter o seguinte conteúdo:
   </para>
<screen># load module <replaceable>MODULE</replaceable> at boot time
<replaceable>MODULE</replaceable></screen>
   <para>
    Se um pacote instalar um arquivo de configuração para carregar um módulo do kernel, o arquivo será instalado em <filename>/usr/lib/modules-load.d</filename>. Se houver dois arquivos de configuração com o mesmo nome, aquele em <filename>/etc/modules-load.d</filename> terá precedência.
   </para>
   <para>
    Para obter mais informações, consulte a página de manual <systemitem>modules-load.d(5)</systemitem>.
   </para>
  </sect2>



  <sect2 xml:id="sec-boot-systemd-advanced-before-local">
   <title>Executando ações antes de carregar um serviço</title>
   <para>
    Com o System V, as ações init que precisam ser executadas antes de carregar um serviço tinham que ser especificadas em <filename>/etc/init.d/before.local</filename>. Esse procedimento não é mais suportado no systemd. Se você precisa executar ações antes de iniciar serviços, faça o seguinte:
   </para>
   <variablelist>
    <varlistentry>
     <term>Carregamento de Módulos do Kernel</term>
     <listitem>
      <para>
       Crie um arquivo drop-in no diretório <filename>/etc/modules-load.d</filename> (consulte <command>man modules-load.d</command> para ver a sintaxe)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
     Criando arquivos ou diretórios, limpando diretórios, mudando a propriedade
     </term>
     <listitem>
      <para>
       Crie um arquivo drop-in em <filename>/etc/tmpfiles.d</filename> (consulte <command>man tmpfiles.d</command> para ver a sintaxe)
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Outras Tarefas</term>
     <listitem>
      <para>
       Crie um arquivo de serviço de sistema, por exemplo <filename>/etc/systemd/system/before.service</filename>, com base no seguinte gabarito:
      </para>
<screen>[Unit]
Before=<replaceable>NAME OF THE SERVICE YOU WANT THIS SERVICE TO BE STARTED BEFORE</replaceable>
[Service]
Type=oneshot
RemainAfterExit=true
ExecStart=<replaceable>YOUR_COMMAND</replaceable>
# beware, executable is run directly, not through a shell, check the man pages
# systemd.service and systemd.unit for full syntax
[Install]
# target in which to start the service
WantedBy=multi-user.target
#WantedBy=graphical.target</screen>
      <para>
       Quando o arquivo de serviço é criado, você deve executar os seguintes comandos (como <systemitem class="username">root</systemitem>):
      </para>
<screen><prompt>tux &gt; </prompt><command>sudo</command> systemctl daemon-reload
<prompt>tux &gt; </prompt><command>sudo</command> systemctl enable before</screen>
      <para>
       Toda vez que você modifica o arquivo de serviço, deve executar:
      </para>
<screen><prompt>tux &gt; </prompt><command>sudo</command> systemctl daemon-reload</screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>



  <sect2 xml:id="sec-boot-systemd-advanced-cgroups">
   <title>Grupos de controle (cgroups) do Kernel</title>
   <para>
    Em um sistema init tradicional do System V, nem sempre é possível atribuir claramente um processo ao serviço que o gerou. Alguns serviços, como o Apache, geram diversos processos de terceiros (por exemplo, processos CGI ou Java) que, por sua vez, geram mais processos. Isso dificulta ou até impossibilita uma atribuição clara. Além do mais, um serviço pode não terminar corretamente, deixando alguns filhos ativos.
   </para>
   <para>
    O systemd resolve este problema colocando cada serviço em seu próprio grupo de controle (cgroup). Cgroups são recursos do kernel que possibilitam agregar processos e todos os seus filhos em grupos hierárquicos organizados. O systemd nomeia cada cgroup de acordo com seu serviço. Como um processo não privilegiado não pode <quote>deixar</quote> seu cgroup, essa é uma forma eficiente de rotular todos os processos gerados por um serviço com o nome do serviço.
   </para>
   <para>
    Para listar todos os processos pertencentes a um serviço, use o comando <command>systemd-cgls</command>. O resultado será parecido com o seguinte exemplo (resumido):
   </para>
   <example>
    <title>Listar todos os processos pertencentes a um serviço</title>
<screen><prompt role="root">root # </prompt>systemd-cgls --no-pager
├─1 /usr/lib/systemd/systemd --switched-root --system --deserialize 20
├─user.slice
│ └─user-1000.slice
│   ├─session-102.scope
│   │ ├─12426 gdm-session-worker [pam/gdm-password]
│   │ ├─15831 gdm-session-worker [pam/gdm-password]
│   │ ├─15839 gdm-session-worker [pam/gdm-password]
│   │ ├─15858 /usr/lib/gnome-terminal-server

[...]

└─system.slice
  ├─systemd-hostnamed.service
  │ └─17616 /usr/lib/systemd/systemd-hostnamed
  ├─cron.service
  │ └─1689 /usr/sbin/cron -n
  ├─postfix.service
  │ ├─ 1676 /usr/lib/postfix/master -w
  │ ├─ 1679 qmgr -l -t fifo -u
  │ └─15590 pickup -l -t fifo -u
  ├─sshd.service
  │ └─1436 /usr/sbin/sshd -D

[...]</screen>
   </example>
   <para>
    Consulte o <xref linkend="cha-tuning-cgroups"/> para obter mais informações sobre os cgroups.
   </para>
  </sect2>

  <sect2 xml:id="sec-boot-systemd-advanced-kill">
   <title>Terminando os serviços (enviando sinais)</title>
   <para>
    Conforme explicado na <xref linkend="sec-boot-systemd-advanced-cgroups"/>, nem sempre é possível atribuir um processo a seu processo de serviço pai em um sistema init do System V. Isso dificulta terminar um serviço e todos os seus filhos. Os processos filhos que não forem terminados permanecerão como processos zumbis.
   </para>
   <para>
    O conceito do systemd de confinar cada serviço em um cgroup possibilita identificar claramente todos os processos filhos de um serviço e, portanto, permite enviar um sinal a cada um desses processos. Use <command>systemctl kill</command> para enviar sinais aos serviços. Para ver uma lista dos sinais disponíveis, consulte <command>man 7 signals</command>.
   </para>
   <variablelist>
    <varlistentry>
     <term>Enviando <systemitem>SIGTERM</systemitem> para um serviço</term>
     <listitem>
      <para>
       <systemitem>SIGTERM</systemitem> é o sinal padrão que é enviado.
      </para>
<screen><prompt>tux &gt; </prompt><command>sudo</command> systemctl kill <replaceable>MY_SERVICE</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Enviando um <replaceable>SINAL</replaceable> para um serviço</term>
     <listitem>
      <para>
       Use a opção <option>-s</option> para especificar o sinal que deve ser enviado.
      </para>
<screen><prompt>tux &gt; </prompt><command>sudo</command> systemctl kill -s <replaceable>SIGNAL</replaceable> <replaceable>MY_SERVICE</replaceable></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Selecionando processos</term>
     <listitem>
      <para>
       Por padrão, o comando <command>kill</command> envia o sinal para <option>todos</option> os processos do cgroup especificado. É possível restringi-lo ao processo <option>control</option> ou <option>main. </option> Este último, por exemplo, é útil para forçar um serviço a recarregar sua configuração enviando <systemitem>SIGHUP</systemitem>:
      </para>
<screen><prompt>tux &gt; </prompt><command>sudo</command> systemctl kill -s SIGHUP --kill-who=main <replaceable>MY_SERVICE</replaceable></screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
  <sect2 xml:id="sec-boot-systemd-dbus">
   <title>Notas importantes sobre o serviço D-Bus</title>

   <para>
     O serviço D-BUS é o barramento de mensagem para comunicação entre clientes systemd e o gerenciador systemd que está sendo executado como pid 1. Embora o <systemitem class="daemon">dbus</systemitem> seja um daemon independente, ele é parte integrante da infraestrutura do init.
   </para>

    <para>
     Terminar ou reiniciar o <systemitem class="daemon">dbus</systemitem> no sistema em execução é semelhante a uma tentativa de terminar ou reiniciar o pid 1. Isso interromperá a comunicação entre cliente e servidor systemd e inutilizará a maioria das funções do systemd.
    </para>

    <para>
     Portanto, terminar ou reiniciar o <systemitem class="daemon">dbus</systemitem> não é recomendado nem suportado.
    </para>

    <para>
     A atualização do <systemitem>dbus</systemitem> ou dos pacotes relacionados ao <systemitem>dbus</systemitem> requer uma reinicialização. Quando estiver em dúvida se uma reinicialização é necessária, execute o comando <command>sudo zypper ps -s</command>. Se <literal>dbus</literal> aparecer entre os serviços listados, será necessário reinicializar o sistema.
    </para>

    <para>
     Saiba que o <systemitem>dbus</systemitem> é atualizado mesmo quando as atualizações automáticas estão configuradas para ignorar os pacotes que exigem reinicialização.
    </para>

  </sect2>



  <sect2 xml:id="sec-boot-systemd-basics-services-debugging">
   <title>Depurando serviços</title>
   <para>
    Por padrão, o systemd não é muito verboso. Se um serviço for iniciado com êxito, nenhuma saída será gerada. Em caso de falha, uma breve mensagem de erro será exibida. Porém, o <command>systemctl status</command> oferece os meios de depurar a inicialização e operação de um serviço.
   </para>
   <para>
    O systemd já vem com um mecanismo de registro (<quote>The Journal</quote> — O Diário) que registra as mensagens do sistema. Isso permite exibir as mensagens de serviço juntamente com as mensagens de status. O comando <command>status</command> funciona de forma parecida com o comando <command>tail</command> e também exibe as mensagens de registro em formatos diferentes, o que faz dele uma poderosa ferramenta de depuração.
   </para>
   <variablelist>
    <varlistentry>
     <term>Mostrar falha na inicialização de serviço</term>
     <listitem>
      <para>
       Sempre que houver falha ao iniciar um serviço, use <command>systemctl status <replaceable>MEU_SERVIÇO</replaceable></command> para obter a mensagem de erro detalhada:
      </para>
<screen><prompt role="root">root # </prompt>systemctl start apache2
Job failed. See system journal and 'systemctl status' for details.
<prompt role="root">root # </prompt>systemctl status apache2
   Loaded: loaded (/usr/lib/systemd/system/apache2.service; disabled)
   Active: failed (Result: exit-code) since Mon, 04 Apr 2018 16:52:26 +0200; 29s ago
   Process: 3088 ExecStart=/usr/sbin/start_apache2 -D SYSTEMD -k start (code=exited, status=1/FAILURE)
   CGroup: name=systemd:/system/apache2.service

Apr 04 16:52:26 g144 start_apache2[3088]: httpd2-prefork: Syntax error on line
205 of /etc/apache2/httpd.conf: Syntax error on li...alHost&gt;</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Mostrar as últimas <replaceable>n</replaceable> mensagens de serviço</term>
     <listitem>
      <para>
       O comportamento padrão do subcomando <command>status</command> é exibir as dez últimas mensagens emitidas por um serviço. Para mudar o número de mensagens exibidas, use o parâmetro <option>--lines=<replaceable>N</replaceable></option>:
      </para>
<screen><prompt>tux &gt; </prompt><command>sudo</command> systemctl status chronyd
<prompt>tux &gt; </prompt><command>sudo</command> systemctl --lines=20 status chronyd</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Mostrar as mensagens de serviço no modo de anexação</term>
     <listitem>
      <para>
       Para exibir um <quote>fluxo ao vivo</quote> das mensagens de serviço, use a opção <option>--follow</option>, que funciona como o <command>tail </command><option>-f</option>:
      </para>
<screen><prompt>tux &gt; </prompt><command>sudo</command> systemctl --follow status chronyd</screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Formato de saída das mensagens</term>
     <listitem>
      <para>
       O parâmetro <option>--output=<replaceable>MODO</replaceable></option> permite mudar o formato de saída das mensagens de serviço. Os modos mais importantes disponíveis são:
      </para>
      <variablelist>
       <varlistentry>
        <term><option>short</option>
        </term>
        <listitem>
         <para>
          O formato padrão. Mostra as mensagens de registro com uma marcação de horário legível.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>verbose</option>
        </term>
        <listitem>
         <para>
          Saída completa com todos os campos.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>cat</option>
        </term>
        <listitem>
         <para>
          Saída resumida sem marcações de horário.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-boot-systemd-info">
  <title>Mais informações</title>

  <para>
   Para obter mais informações sobre o systemd, consulte os seguintes recursos online:
  </para>

  <variablelist>
   <varlistentry>
    <term>Home page</term>
    <listitem>
     <para>
      <link xlink:href="http://www.freedesktop.org/wiki/Software/systemd"/>
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>systemd para administradores</term>
    <listitem>
     <para>
      Lennart Pöttering, um dos criadores do systemd, escreveu uma série de entradas de blog (13 até o fechamento deste capítulo). Encontre-os em <link xlink:href="http://0pointer.de/blog/projects"/>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
</chapter>
