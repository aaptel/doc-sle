<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="klp.xml" version="5.0" xml:id="cha-klp" xml:lang="zh-tw">
 <title>使用 KLP 的即時核心修補</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker/>
   <dm:translation>是</dm:translation>
  </dm:docmanager>
  <abstract>
   <para>
    本文件介紹核心即時修補 (KLP) 技術的基本原理，並提供 SLE Live Patching 服務的使用指導方針。
   </para>
  </abstract>
 </info>
 <para>
  KLP 是一項即時修補技術，使用它無需停止核心，就能在執行時期修補 Linux 核心。它可以最大程度地增大系統執行時間，從而提高系統可用性，這對於關鍵任務系統而言非常重要。該項技術還允許動態動態修補核心，鼓勵使用者安裝關鍵的安全性更新，而不必將其推遲到排程的停機時間。
 </para>
 <para>
   啟用 KLP 無需執行特殊步驟，只需啟用 Live Patching 服務，然後套用可用的修補程式即可。該服務是一般軟體管理系統的一部分，使用常用套件管理工具安裝 (或移除) 修補程式。無需安裝或手動選取特殊核心。
</para>
 <para>
  KLP 修補程式是一個核心模組，旨在取代核心中的全部函數。核心即時修補主要提供核心內基礎結構，用於在執行時期將修補的代碼與基本核心代碼相整合。
 </para>
 <para>
  本文件中提供的資訊與 AMD64/Intel 64 和 POWER 架構相關。Xen 監管程式支援 KLP。
 </para>
 <sect1 xml:id="sec-klp-advantages">
  <title>核心即時修補的優勢</title>

  <para>
   當發現應儘快修復的嚴重弱點或系統穩定性問題時，使用 KLP 的核心即時修補能夠快速做出緊急回應。該技術不適合用於非時間關鍵型的已排程更新。
  </para>

  <para>
   核心即時修補的一般使用案例包括：包含巨量 RAM 且開機時間通常長達 15 分鐘或以上的記憶體資料庫之類的系統、需要持續數周或數月且不能重新啟動的大規模模擬，或是向大量消費者持續提供服務的基礎結構建構區塊。
  </para>

  <para>
   核心即時修補的主要優勢是它永不要求停止核心，哪怕是短暫停止。
  </para>

  <para>
   KLP 修補程式是 RPM 套件中的一個 <filename>.ko</filename> 核心模組。可以在安裝或更新 套件時，使用 <command>insmod</command> 指令將該模組插入核心。核心即時修補將取代核心中的全部函數，即使這些函數正在執行。如果需要，可以使用更新的 KLP 模組取代現有修補程式。
  </para>

  <para>
   核心即時修補也很精簡 - 因為利用了其他標準 Linux 技術，它只包含少量的程式碼。
  </para>
 </sect1>
 <sect1 xml:id="sec-klp-low-level">
  <title>核心即時修補的低階函數</title>

  <para>
   核心即時修補使用 ftrace 基礎結構執行修補。下面介紹了在 AMD64/Intel 64 架構上的實作。
  </para>

  <para>
   為了修補某個核心函數，核心即時修補要求該函數的開頭有一定的空間，以便插入指向新函數的跳躍點。此空間是在開啟函數評估的情況下，於核心編譯期間由 GCC 配置的。具體而言，將在核心函數的開頭注入一個 5 位元組呼叫指令。將此類經過檢測的核心開機時，評估呼叫將由 5 位元組 NOP (無操作) 指令取代。
  </para>

  <para>
   修補開始之後，第一個位元組將由 INT3 (斷點) 指令取代。這可以確定 5 位元組指令取代動作的不可部分完成性。其他四個位元組將由新函數的位址取代。最後，第一個位元組將由 JMP (長跳躍) OpCode 取代。
  </para>

  <para>
   在整個過程中，將會使用處理器間不可遮罩岔斷 (IPI NMI) 來衝洗系統中其他 CPU 的理論式解碼佇列。這樣，無需停止核心 (哪怕是短暫性的停止)，就能切換到新的函數。IPI NMI 產生的岔斷可以毫秒為單位測量，並且不被視為服務岔斷，因為無論在哪種情況下，這些岔斷都是在核心執行時發生的。
  </para>

  <para>
   永遠不會修補呼叫者。被呼叫者的 NOP 將由指向新函數的 JMP 取代。JMP 指令會永久保留。這種運作方式可以處理好函數指標 (包括結構中的指標)，並且不需要儲存任何舊資料就能取消修補。
  </para>

  <para>
   但是，這些步驟本身並不足夠妥善：因為函數的取代可能會完成一部分，核心某個部分中修復的新函數可能仍會呼叫其他位置的某個舊函數，反之亦然。如果函數介面的語意在修補程式中發生變更，將會因應性地造成混亂。
  </para>

  <para>
   因此，在取代所有函數之前，核心即時修補使用以彈性機制為基礎且類似於 RCU (讀取-複製-更新) 的方案，來確保每個使用者空間線串、核心線串和核心中斷在全域檢視中都保持一致。將在每個核心入口和出口中，為每個線串設定一個旗標。這樣，一個舊函數總是會呼叫另一個舊函數，而一個新函數總是會呼叫另一個新函數。為所有程序設定「new universe」旗標之後，修補即告完成，此時，可以移除彈性機制，程式碼可以全速執行，且不會對效能產生影響，不過，每個修補的函數需要經歷超長時間的跳轉。
  </para>
 </sect1>

  <sect1 xml:id="sec-klp-install-patch-activate">
   <title>啟用 SLE Live Patching</title>
   <para>
    若要在您的系統上啟用 SLE Live Patching，請遵循以下步驟：
   </para>
   <procedure>
    <step>
     <para>
      您的 SLES 系統必須已註冊。可以在系統安裝期間註冊該系統，也可以在安裝後使用 YaST <guimenu>產品註冊</guimenu>模組 (<command>yast2 registration</command>) 註冊該系統。如果您的 SLES 系統已註冊，但 SLE Live Patching 尚未啟用，請執行 <command>yast2 registration</command> 指令，然後按一下<guimenu>選取延伸</guimenu>。
     </para>
    </step>
    <step>
     <para>
      在可用延伸清單中選取 <guimenu>SUSE Linux Enterprise Live Patching 15</guimenu>，然後按<guimenu>下一步</guimenu>。
     </para>
    </step>
    <step>
     <para>
      確認授權條款並按<guimenu>下一步</guimenu>。
     </para>
    </step>
    <step>
     <para>
      輸入您的 SLE Live Patching 註冊代碼並按一下<guimenu>下一步</guimenu>。
     </para>
    </step>
    <step>
     <para>
      檢查<guimenu>安裝摘要</guimenu>和所選的<guimenu>模式</guimenu>。系統會為安裝自動選取模式 <systemitem>Live Patching</systemitem> 和 <systemitem>SLE Live Patching Lifecycle Data</systemitem>，同時為符合相依性可能還會選取安裝一些其他套件。 
     </para>
    </step>
    <step>
     <para>
      按一下<guimenu>接受</guimenu>完成安裝。也就是說，會在您的系統上安裝基礎核心即時修補元件、初始即時修補程式，以及任何相依性套件。
     </para>
    </step>
   </procedure>
  </sect1>

  <sect1 xml:id="sec-klp-install-patch-update">
   <title>安裝和移除修補程式</title>
   <para>
       本節介紹如何尋找、安裝和移除 KLP 修補程式。
   </para>
     <sect2 xml:id="sec-klp-install">
  <title>安裝 KLP 修補程式</title>
     
   <procedure>
    <step>
     <para>
      在安裝新的修補程式之前，請執行 <command>klp status</command> 指令查詢目前狀態，該狀態必須是 <literal>ready</literal> 而不能是 <literal>in_progress</literal>。只有在完成前面的修補程式安裝之後，才能套用新的修補程式。只有在喚醒並移除所有睡眠程序之後，才能完全消除舊核心函數的呼叫。這樣可以節省大量的時間。但我們並不認為使用舊核心函數的睡眠程序存在安全性問題。(如需如何管理長時間 <literal>in_progress</literal> 狀態的資訊，請參閱<xref linkend="sec-klp-exec-threads"/>。)
     </para>     
     </step>
    <step>
     <para>
         使用一般套件管理系統 <command>zypper</command> 或 YaST 檢視和安裝可用的修補程式。以下範例將搜尋可用的修補程式，然後安裝最新的修補程式。不需要按順序逐一安裝所有修補程式；存在多個可用的修補程式時，只需安裝最新的修補程式。
     </para>
     <screen><prompt>tux &gt; </prompt><command>sudo</command> zypper se kernel-livepatch 
| kernel-livepatch-5_3_18-8_16-default  | Kernel live patch module  | package   
| kernel-livepatch-5_3_18-8_19-default  | Kernel live patch module  | package   
| kernel-livepatch-5_3_18-8_22-default  | Kernel live patch module  | package

<prompt>tux &gt; </prompt><command>sudo</command> zypper in kernel-livepatch-5_3_18-8_22-default</screen>     
    </step>
   </procedure>
  </sect2>
 
  <sect2 xml:id="sec-klp-remove">
  <title>移除 KLP 修補程式</title>
  <para>
      如果您需要移除某個 KLP 修補程式，請使用 <command>zypper</command>，就像移除任何其他套件一樣。使用 <command>zypper</command> 搜尋 <literal>kernel-livepatch</literal>，列出已安裝的即時修補程式套件：
  </para>
     <screen><prompt>tux &gt; </prompt><command>sudo</command> zypper se -kernel-livepatch 
  | kernel-livepatch-5_3_18-8_16-default  | Kernel live patch module  | package   
  | kernel-livepatch-5_3_18-8_19-default  | Kernel live patch module  | package   
i | kernel-livepatch-5_3_18-8_22-default  | Kernel live patch module  | package
</screen>
  <procedure>
   <step>
    <para>
     使用 <command>zypper</command> 移除修補程式：
    </para>
<screen><prompt>tux &gt; </prompt><command>sudo</command> zypper rm kernel-livepatch-5_3_18-8_22-default</screen>
   </step>
   <step>
    <para>
     等待 <systemitem>initrd</systemitem> 自動重建，然後將機器重新開機。
    </para>
   </step>
  </procedure>
</sect2>
 </sect1>
 
  <sect1 xml:id="sec-klp-klp">
  <title><command>klp</command> 工具</title>

  <para>
   使用 <command>klp</command> 工具可以簡化一些核心即時修補管理任務。可用的指令為：
  </para>

  <variablelist>
   <varlistentry>
    <term><command>klp status</command></term>
    <listitem>
     <para>
      顯示核心即時修補的總體狀態 (<literal>ready</literal> 或 <literal>in_progress</literal>)。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>klp patches</command></term>
    <listitem>
     <para>
      顯示已載入 KLP 修補程式的清單。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>klp blocking</command></term>
    <listitem>
     <para>
      列出阻止完成核心即時修補的程序。預設只會列出 PID。指定 <option>-v</option> 可以列顯指令行 (如果可用)。<option>-vv</option> 顯示堆疊追蹤。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
  <para>
   如需詳細資訊，請參閱 <command>man klp</command>。
  </para>
 </sect1>

 <sect1 xml:id="sec-klp-exec-threads">
  <title>阻塞的核心執行線串</title>

  <para>
   核心線串必須已準備好處理核心即時修補。協力廠商軟體可能不支援核心即時修補，並可能會衍生核心執行線串。這些線串會無限期阻擋修補程序。做為緊急應對措施，您可以透過將 <literal>0</literal> 寫入 <filename>/sys/kernel/livepatch/*/transition/</filename> (請將星號萬用字元取代為您的檔案名稱)，來強制完成修補程序，而不必等到所有執行線串都通過安全性檢查點。在執行此程序之前，請先諮詢 SUSE 支援人員。
  </para>
</sect1>

 <sect1 xml:id="sec-klp-lifecycle">
  <title>修補程式生命週期</title>

  <para>
   可以使用 <command>zypper lifecycle</command> 來查看線上修補程式的過期日期。(確認套件
   <package>lifecycle-data-sle-module-live-patching</package> 已安裝。)
  </para>

  <para>
   當到了修補程式的過期日期時，將不再提供此核心版本的更多線上修補程式。請在線上修補程式生命週期期限結束之前規劃核心更新。
  </para>

  <para>
   如需 <command>zypper lifecycle</command> 的詳細資料，請參閱《<emphasis>管理員指南</emphasis>》中的「<emphasis>顯示生命週期資訊</emphasis>」。
  </para>
 </sect1>

 <sect1 xml:id="sec-klp-scope">
  <title>核心即時修補技術的範圍</title>

  <para>
   核心即時修補基於函數取代。資料結構的變更只能透過核心即時修補間接完成。因此，變更核心資料結構時需要特別小心，如果變更幅度太大，可能需要重新開機。此外，對於使用一個編譯器來編譯舊核心而使用另一個編譯器來編譯修補程式的情況，核心即時修補可能無法處理。
  </para>

  <para>
   由於核心即時修補的工作方式，其對衍生大量核心線串的協力廠商模組的支援有限。

  </para>
 </sect1>
 <sect1 xml:id="sec-klp-scope-patching">
  <title>SLE Live Patching 的應用範圍</title>

  <para>
   SLE Live Patching 的應用範圍包括：SUSE 通用弱點評分系統 (CVSS；SUSE CVSS 以 CVSS v3.0 系統為基礎) 層級 7 以上弱點的修復，以及與系統穩定性或資料損毀相關的錯誤修復。無法針對滿足上述所有準則的所有修復類型產生即時修補程式。如果出於技術原因而無法產生核心即時修補程式，SUSE 有權不發佈修復。如需做為 SUSE CVSS 評級基礎的 CVSS 的詳細資訊，請參閱 <link xlink:href="https://www.first.org/cvss/"/>。
  </para>
 </sect1>
 <sect1 xml:id="sec-klp-support-interaction">
  <title>使用支援流程與我們互動</title>

  <para>
   在與 SUSE 支援人員共同解決技術難題時，您可能會收到一個程式暫時修復 (PTF)。我們可能會針對各種套件 (包括構成 SLE Live Patching 基礎的套件) 發佈 PTF。
  </para>

  <para>
   您可以像往常一樣安裝符合前一節中所述條件的核心即時修補 PTF，SUSE 可確保無需將有問題的系統重新開機，並且將來的即時更新也可以正常套用。
  </para>

  <para>
   針對基礎核心發佈的 PTF 會中斷即時修補程序。首先，安裝 PTF 核心意味著需要重新開機，因為在執行時期無法取代整個核心。其次，需要再次重新開機，以便將 PTF 取代為對其發佈了即時修補程式的任何定期維護更新。
  </para>

  <para>
   可將 SLE Live Patching 中其他套件的 PTF 視為享有正常擔保的一般 PTF。
  </para>
 </sect1>
</chapter>
